[
  {
    "objectID": "notebooks/crv_animation.html",
    "href": "notebooks/crv_animation.html",
    "title": "",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom matplotlib.patches import ConnectionPatch, Rectangle\nfrom scipy.stats import uniform as un\nfrom functools import partial\n\n\ndef pdf(x):\n    if (x &lt; 1):\n        return 0\n    elif (x &gt;= 1) and (x &lt;= 5):\n        return (5 / 4) * (1 / (x ** 2))\n    else:\n        return 0\n\ndef cdf(x):\n    if (x &lt; 1):\n        return 0\n    elif (x &gt;= 1) and (x &lt;= 5):\n        return (5*x - 5) / (4 * x)\n    else:\n        return 1\n\n\nfig, (ax_pdf, ax_cdf) = plt.subplots(\n    nrows=2,\n    sharex=True,\n    figsize=(6, 6),\n)\n\nplt.rcParams['axes.grid'] = True\nplt.rc('legend', fontsize=15)\nfig.suptitle('In class example', fontsize=16)\nx = np.arange(-1, 8, 0.01)\nNx = x.shape[0]\ny_pdf = np.empty((Nx))\ny_cdf = np.empty((Nx))\nfor i in range(Nx):\n    y_pdf[i] = pdf(x[i])\nfor i in range(Nx):\n    y_cdf[i] = cdf(x[i])\nax_cdf.plot(x, y_cdf, label=r'$F_X(x)$')\nax_pdf.plot(x, y_pdf, label=r'$f_X(x)$')\n\nax_pdf.legend()\nax_cdf.legend()\n\n# plt.show()\n# plt.savefig(\"pdf_cdf_example.pdf\")\n\nY1 = y_pdf\nY2 = np.zeros(x.shape[0])\n\nx_a, y_a = x[300], cdf(x[300])\nx_b, y_b = x[500], cdf(x[500])\n\n\n# draw full curve to set view limits in right Axes\n# Plot the 0th frame\nfill_a = ax_pdf.fill_between(x[:300], Y1[:300], color='m', alpha=0.6, label=r'$P(X &lt; 2)$ = F_X(2)')\nfill = ax_pdf.fill_between(x[:500], Y1[:500], color='g', alpha=0.4, label=r'$P(X &lt; 4)$ = F_X(4)')\npoint, = ax_cdf.plot(x[0], 0, \"o\", color='m')\npoint.set_data([x_a], [y_a])\npoint_b, = ax_cdf.plot(x[0], 0, \"o\", color='g')\npoint_b.set_data([x_b], [y_b])\n\n# draw connecting line between both graphs\ncon = ConnectionPatch(\n    (x[0], 0),\n    (x[0], 0),\n    \"data\",\n    \"data\",\n    axesA=ax_cdf,\n    axesB=ax_pdf,\n    color=\"m\",\n    ls=\"dotted\",\n)\ncon.xy1 = x_a, y_a\ncon.xy2 = x_a, 0\nfig.add_artist(con)\n\n# draw connecting line between both graphs\ncon_b = ConnectionPatch(\n    (x[0], 0),\n    (x[0], 0),\n    \"data\",\n    \"data\",\n    axesA=ax_cdf,\n    axesB=ax_pdf,\n    color=\"g\",\n    ls=\"dotted\",\n)\ncon_b.xy1 = x_b, y_b\ncon_b.xy2 = x_b, 0\nfig.add_artist(con_b)\n\nglobal tmp_vert\ntmp_vert = np.zeros((2,2))\ntmp_vert[0, 0], tmp_vert[0,0] = x[0], 0\ntmp_vert[1, 0], tmp_vert[1,1] = x[0], 0\nfill.set_paths([tmp_vert], False)\n\n\ndef animate(i):\n    x = np.arange(-1, 8, 0.01)\n    add_vert = np.array([x[i], 0])\n    path = fill.get_paths()[0]\n    vertices = path.vertices\n    vertices[-1,0], vertices[-1,1] = x[i], pdf(x[i])\n    vertices = np.vstack((vertices, add_vert))\n    fill.set_paths([vertices], False)\n    \n\n    # # Elements 1:Nx+1 encode the upper curve\n    # vertices[1:i + 1, 1] = Y1[:i]\n    x, y = x[i], cdf(x[i])\n    point.set_data([x], [y])\n    con.xy1 = x, y\n    con.xy2 = x, 0\n    return point, fill, con\n\nfr = np.arange(Nx)\nani = animation.FuncAnimation(\n    fig,\n    animate,\n    interval=7,\n    blit=False,  # blitting can't be used with Figure artists\n    frames=fr,\n    repeat_delay=100,\n)\n\n# plt.show()\n\nf = \"in_class.gif\"\nwritergif = animation.PillowWriter(fps=15)\nani.save(f, writer=writergif)\n\n\nx[300]\n\n\nrv = un(0, 10)\n\nfig, (ax_obj, ax_pdf, ax_cdf) = plt.subplots(\n    nrows=3,\n    sharex=True,\n    figsize=(6, 6),\n)\nstrip = Rectangle((0, 0), 10, 0.2, ec=\"none\")\n# ax_pdf.yaxis.set_visible(False)\nax_pdf.set_ylabel(r'$\\rho(x)$', rotation='horizontal', labelpad=12)\nax_cdf.set_ylabel(r'$m(x)$', rotation='horizontal', labelpad=12)\nfig.suptitle('Physical example', fontsize=16)\nx = np.arange(-3, 13.1, 0.1)\nNx = x.shape[0]\nax_obj.get_yaxis().set_visible(False)\nax_obj.add_artist(strip)\ny_pdf = rv.pdf(x)\ny_cdf = rv.cdf(x)\ncdf, = ax_cdf.plot(x, y_cdf, \"k\")\npdf, = ax_pdf.plot(x, y_pdf)\n\nY1 = y_pdf\nY2 = np.zeros(x.shape[0])\n\n# draw full curve to set view limits in right Axes\n# Plot the 0th frame\n\nfill = ax_pdf.fill_between(x[:2], Y1[:2], color='r', alpha=0.5)\npath = fill.get_paths()[0]\nvertices = path.vertices\nprint(vertices)\npoint, = ax_cdf.plot(x[0], 0, \"o\", color='r')\n\n# draw connecting line between both graphs\ncon = ConnectionPatch(\n    (x[0], 0),\n    (x[0], 0),\n    \"data\",\n    \"data\",\n    axesA=ax_cdf,\n    axesB=ax_pdf,\n    color=\"r\",\n    ls=\"dotted\",\n)\nfig.add_artist(con)\nglobal tmp_vert\ntmp_vert = np.zeros((2,2))\ntmp_vert[0, 0], tmp_vert[0,0] = x[0], 0\ntmp_vert[1, 0], tmp_vert[1,1] = x[0], 0\nfill.set_paths([tmp_vert], False)\n\n\ndef animate(i):\n    # pdf.set_data(x_dom, norm.pdf(x_dom))\n    rv = un(0, 10)\n    x = np.arange(-3, 13.1, 0.1)\n    add_vert = np.array([x[i], 0])\n    path = fill.get_paths()[0]\n    vertices = path.vertices\n    vertices[-1,0], vertices[-1,1] = x[i], rv.pdf(x[i])\n    vertices = np.vstack((vertices, add_vert))\n    fill.set_paths([vertices], False)\n    \n\n    # # Elements 1:Nx+1 encode the upper curve\n    # vertices[1:i + 1, 1] = Y1[:i]\n    x, y = x[i], rv.cdf(x[i])\n    point.set_data([x], [y])\n    con.xy1 = x, y\n    con.xy2 = x, 0\n    return point, fill, con\n\nfr = np.arange(Nx)\nani = animation.FuncAnimation(\n    fig,\n    animate,\n    interval=7,\n    blit=False,  # blitting can't be used with Figure artists\n    frames=fr,\n    repeat_delay=100,\n)\n\n# plt.show()\n\nf = \"pic_distrib.gif\"\nwritergif = animation.PillowWriter(fps=10)\nani.save(f, writer=writergif)\n\n\nl = 5.6+1.53333\ndef pdf(x):\n    l = 5.6+1.53333\n    if (x &lt; 0):\n        return 0\n    elif (x&gt;=0) and (x&lt;4.4):\n        return 0.12\n    elif (x&gt;=4.4) and (x&lt;=5.6):\n        return (-0.5 * (x**2) + 5*x - 12.2)\n    elif (x&gt;5.6) and (x&lt;l):\n        return 0.12\n    else:\n        return 0\n\n\ndef cdf(x):\n    l = 5.6+1.53333\n    if (x &lt; 0):\n        return 0\n    elif (x&gt;=0) and (x&lt;=4.4):\n        return 0.12 * x\n    elif (x&gt;4.4) and (x&lt;=5.6):\n        return (cdf(4.4) + -0.166667 * (x**3) + 2.5 * (x**2) - 12.2 * x + 19.4773)\n    elif (x&gt;5.6) and (x&lt;l):\n        return cdf(5.6) + (x-5.6) * 0.12\n    else:\n        return 1\n\n\ncdf(5.7)\n\n\nfig, (ax_obj, ax_pdf, ax_cdf) = plt.subplots(\n    nrows=3,\n    sharex=True,\n    figsize=(6, 6),\n)\nstrip = Rectangle((0, 0), l, 0.2, ec=\"none\")\n# ax_pdf.yaxis.set_visible(False)\nax_pdf.set_ylabel(r'$\\rho(x)$', rotation='horizontal', labelpad=12)\nax_cdf.set_ylabel(r'$m(x)$', rotation='horizontal', labelpad=12)\nfig.suptitle('Physical example 2', fontsize=16)\nx = np.arange(-3, 10, 0.1)\nNx = x.shape[0]\ny_pdf = np.empty((Nx))\ny_cdf = np.empty((Nx))\nax_obj.get_yaxis().set_visible(False)\nax_obj.add_artist(strip)\nfor i in range(Nx):\n    y_pdf[i] = pdf(x[i])\nfor i in range(Nx):\n    y_cdf[i] = cdf(x[i])\n\ncdf_plot, = ax_cdf.plot(x, y_cdf, \"k\")\npdf_plot, = ax_pdf.plot(x, y_pdf)\n\nY1 = y_pdf\nY2 = np.zeros(x.shape[0])\n\n# draw full curve to set view limits in right Axes\n# Plot the 0th frame\nfill = ax_pdf.fill_between(x[:1], Y1[:1], color='r', alpha=0.5)\npoint, = ax_cdf.plot(x[0], 0, \"o\", color='r')\n\n# draw connecting line between both graphs\ncon = ConnectionPatch(\n    (x[0], 0),\n    (x[0], 0),\n    \"data\",\n    \"data\",\n    axesA=ax_cdf,\n    axesB=ax_pdf,\n    color=\"r\",\n    ls=\"dotted\",\n)\nfig.add_artist(con)\n\nglobal tmp_vert\ntmp_vert = np.zeros((2,2))\ntmp_vert[0, 0], tmp_vert[0,0] = x[0], 0\ntmp_vert[1, 0], tmp_vert[1,1] = x[0], 0\nfill.set_paths([tmp_vert], False)\n\n\ndef animate(i):\n    # pdf.set_data(x_dom, norm.pdf(x_dom))\n    x = np.arange(-3, 10, 0.1)\n    add_vert = np.array([x[i], 0])\n    path = fill.get_paths()[0]\n    vertices = path.vertices\n    vertices[-1,0], vertices[-1,1] = x[i], pdf(x[i])\n    vertices = np.vstack((vertices, add_vert))\n    fill.set_paths([vertices], False)\n    \n\n    # # Elements 1:Nx+1 encode the upper curve\n    # vertices[1:i + 1, 1] = Y1[:i]\n    x, y = x[i], cdf(x[i])\n    point.set_data([x], [y])\n    con.xy1 = x, y\n    con.xy2 = x, 0\n    return point, fill, con\n\nfr = np.arange(Nx)\nani = animation.FuncAnimation(\n    fig,\n    animate,\n    interval=7,\n    blit=False,  # blitting can't be used with Figure artists\n    frames=fr,\n    repeat_delay=100,\n)\n\n# plt.show()\n\nf = \"strip_with_incl.gif\"\nwritergif = animation.PillowWriter(fps=10)\nani.save(f, writer=writergif)\n\n\ndef pdf(x):\n    if (x &lt; 0):\n        return 0\n    elif (x&gt;=0) and (x&lt;=2):\n        return (x**3) / 4\n    else:\n        return 0\n\n\ndef cdf(x):\n    if (x &lt; 0):\n        return 0\n    elif (x&gt;=0) and (x&lt;=2):\n        return (x ** 4) / 16\n    else:\n        return 1\n\nfig, (ax_pdf, ax_cdf) = plt.subplots(\n    nrows=2,\n    sharex=True,\n    figsize=(6, 6),\n)\n\n# ax_pdf.yaxis.set_visible(False)\nax_pdf.set_ylabel(r'$f_X(x)$', rotation='horizontal', labelpad=12)\nax_cdf.set_ylabel(r'$F_X(x)$', rotation='horizontal', labelpad=12)\nfig.suptitle(r'$x^3 / 4$ density function', fontsize=16)\nx = np.arange(-2, 6, 0.05)\nNx = x.shape[0]\ny_pdf = np.empty((Nx))\ny_cdf = np.empty((Nx))\n\nfor i in range(Nx):\n    y_pdf[i] = pdf(x[i])\nfor i in range(Nx):\n    y_cdf[i] = cdf(x[i])\n\ncdf_plot, = ax_cdf.plot(x, y_cdf, \"k\")\npdf_plot, = ax_pdf.plot(x, y_pdf)\n\nY1 = y_pdf\nY2 = np.zeros(x.shape[0])\n\n# draw full curve to set view limits in right Axes\n# Plot the 0th frame\nfill = ax_pdf.fill_between(x[:1], Y1[:1], color='r', alpha=0.5)\npoint, = ax_cdf.plot(x[0], 0, \"o\", color='r')\n\n# draw connecting line between both graphs\ncon = ConnectionPatch(\n    (x[0], 0),\n    (x[0], 0),\n    \"data\",\n    \"data\",\n    axesA=ax_cdf,\n    axesB=ax_pdf,\n    color=\"r\",\n    ls=\"dotted\",\n)\nfig.add_artist(con)\n\nglobal tmp_vert\ntmp_vert = np.zeros((2,2))\ntmp_vert[0, 0], tmp_vert[0,0] = x[0], 0\ntmp_vert[1, 0], tmp_vert[1,1] = x[0], 0\nfill.set_paths([tmp_vert], False)\n\n\ndef animate(i):\n    # pdf.set_data(x_dom, norm.pdf(x_dom))\n    x = np.arange(-2, 6, 0.05)\n    add_vert = np.array([x[i], 0])\n    path = fill.get_paths()[0]\n    vertices = path.vertices\n    vertices[-1,0], vertices[-1,1] = x[i], pdf(x[i])\n    vertices = np.vstack((vertices, add_vert))\n    fill.set_paths([vertices], False)\n    \n\n    # # Elements 1:Nx+1 encode the upper curve\n    # vertices[1:i + 1, 1] = Y1[:i]\n    x, y = x[i], cdf(x[i])\n    point.set_data([x], [y])\n    con.xy1 = x, y\n    con.xy2 = x, 0\n    return point, fill, con\n\nfr = np.arange(Nx)\nani = animation.FuncAnimation(\n    fig,\n    animate,\n    interval=7,\n    blit=False,  # blitting can't be used with Figure artists\n    frames=fr,\n    repeat_delay=100,\n)\n\n# plt.show()\n\nf = \"3a.gif\"\nwritergif = animation.PillowWriter(fps=10)\nani.save(f, writer=writergif)\n\n\ndef pdf(x):\n    if (x &lt; 0):\n        return 0\n    elif (x&gt;=0) and (x&lt;=1):\n        return 2 * x\n    else:\n        return 0\n\n\ndef cdf(x):\n    if (x &lt; 0):\n        return 0\n    elif (x&gt;=0) and (x&lt;=1):\n        return (x ** 2)\n    else:\n        return 1\n\nfig, (ax_pdf, ax_cdf) = plt.subplots(\n    nrows=2,\n    sharex=True,\n    figsize=(6, 6),\n)\n\n# ax_pdf.yaxis.set_visible(False)\nax_pdf.set_ylabel(r'$f_X(x)$', rotation='horizontal', labelpad=12)\nax_cdf.set_ylabel(r'$F_X(x)$', rotation='horizontal', labelpad=12)\nfig.suptitle(r'$2x$ density function', fontsize=16)\nx = np.arange(-2, 6, 0.05)\nNx = x.shape[0]\ny_pdf = np.empty((Nx))\ny_cdf = np.empty((Nx))\n\nfor i in range(Nx):\n    y_pdf[i] = pdf(x[i])\nfor i in range(Nx):\n    y_cdf[i] = cdf(x[i])\n\ncdf_plot, = ax_cdf.plot(x, y_cdf, \"k\")\npdf_plot, = ax_pdf.plot(x, y_pdf)\n\nY1 = y_pdf\nY2 = np.zeros(x.shape[0])\n\n# draw full curve to set view limits in right Axes\n# Plot the 0th frame\nfill = ax_pdf.fill_between(x[:1], Y1[:1], color='r', alpha=0.5)\npoint, = ax_cdf.plot(x[0], 0, \"o\", color='r')\n\n# draw connecting line between both graphs\ncon = ConnectionPatch(\n    (x[0], 0),\n    (x[0], 0),\n    \"data\",\n    \"data\",\n    axesA=ax_cdf,\n    axesB=ax_pdf,\n    color=\"r\",\n    ls=\"dotted\",\n)\nfig.add_artist(con)\n\nglobal tmp_vert\ntmp_vert = np.zeros((2,2))\ntmp_vert[0, 0], tmp_vert[0,0] = x[0], 0\ntmp_vert[1, 0], tmp_vert[1,1] = x[0], 0\nfill.set_paths([tmp_vert], False)\n\n\ndef animate(i):\n    # pdf.set_data(x_dom, norm.pdf(x_dom))\n    x = np.arange(-2, 6, 0.05)\n    add_vert = np.array([x[i], 0])\n    path = fill.get_paths()[0]\n    vertices = path.vertices\n    vertices[-1,0], vertices[-1,1] = x[i], pdf(x[i])\n    vertices = np.vstack((vertices, add_vert))\n    fill.set_paths([vertices], False)\n    \n\n    # # Elements 1:Nx+1 encode the upper curve\n    # vertices[1:i + 1, 1] = Y1[:i]\n    x, y = x[i], cdf(x[i])\n    point.set_data([x], [y])\n    con.xy1 = x, y\n    con.xy2 = x, 0\n    return point, fill, con\n\nfr = np.arange(Nx)\nani = animation.FuncAnimation(\n    fig,\n    animate,\n    interval=7,\n    blit=False,  # blitting can't be used with Figure artists\n    frames=fr,\n    repeat_delay=100,\n)\n\n# plt.show()\n\nf = \"1.gif\"\nwritergif = animation.PillowWriter(fps=10)\nani.save(f, writer=writergif)\n\n\ndef pdf(x):\n    if (x &lt; 10):\n        return 0\n    else:\n        return (10 / x ** 2)\n\n\ndef cdf(x):\n    if (x &lt; 10):\n        return 0\n    else:\n        return (1 - 10 / x)\n\nfig, (ax_pdf, ax_cdf) = plt.subplots(\n    nrows=2,\n    sharex=True,\n    figsize=(6, 6),\n)\n\n# ax_pdf.yaxis.set_visible(False)\nax_pdf.set_ylabel(r'$f_X(x)$', rotation='horizontal', labelpad=12)\nax_cdf.set_ylabel(r'$F_X(x)$', rotation='horizontal', labelpad=12)\nfig.suptitle(r'$10 / x^2$ density function', fontsize=16)\nx = np.arange(8, 40, 0.25)\nNx = x.shape[0]\ny_pdf = np.empty((Nx))\ny_cdf = np.empty((Nx))\n\nfor i in range(Nx):\n    y_pdf[i] = pdf(x[i])\nfor i in range(Nx):\n    y_cdf[i] = cdf(x[i])\n\ncdf_plot, = ax_cdf.plot(x, y_cdf, \"k\")\npdf_plot, = ax_pdf.plot(x, y_pdf)\n\nY1 = y_pdf\nY2 = np.zeros(x.shape[0])\n\n# draw full curve to set view limits in right Axes\n# Plot the 0th frame\nfill = ax_pdf.fill_between(x[:1], Y1[:1], color='r', alpha=0.5)\npoint, = ax_cdf.plot(x[0], 0, \"o\", color='r')\n\n# draw connecting line between both graphs\ncon = ConnectionPatch(\n    (x[0], 0),\n    (x[0], 0),\n    \"data\",\n    \"data\",\n    axesA=ax_cdf,\n    axesB=ax_pdf,\n    color=\"r\",\n    ls=\"dotted\",\n)\nfig.add_artist(con)\n\nglobal tmp_vert\ntmp_vert = np.zeros((2,2))\ntmp_vert[0, 0], tmp_vert[0,0] = x[0], 0\ntmp_vert[1, 0], tmp_vert[1,1] = x[0], 0\nfill.set_paths([tmp_vert], False)\n\n\ndef animate(i):\n    # pdf.set_data(x_dom, norm.pdf(x_dom))\n    x = np.arange(8, 40, 0.25)\n    add_vert = np.array([x[i], 0])\n    path = fill.get_paths()[0]\n    vertices = path.vertices\n    vertices[-1,0], vertices[-1,1] = x[i], pdf(x[i])\n    vertices = np.vstack((vertices, add_vert))\n    fill.set_paths([vertices], False)\n    \n\n    # # Elements 1:Nx+1 encode the upper curve\n    # vertices[1:i + 1, 1] = Y1[:i]\n    x, y = x[i], cdf(x[i])\n    point.set_data([x], [y])\n    con.xy1 = x, y\n    con.xy2 = x, 0\n    return point, fill, con\n\nfr = np.arange(Nx)\nani = animation.FuncAnimation(\n    fig,\n    animate,\n    interval=7,\n    blit=False,  # blitting can't be used with Figure artists\n    frames=fr,\n    repeat_delay=100,\n)\n\n# plt.show()\n\nf = \"2.gif\"\nwritergif = animation.PillowWriter(fps=10)\nani.save(f, writer=writergif)"
  },
  {
    "objectID": "notebooks/clt.html",
    "href": "notebooks/clt.html",
    "title": "Frequentist probability",
    "section": "",
    "text": "import math\nimport seaborn as sns\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport scipy.stats as stats\nfrom scipy.stats import randint, norm"
  },
  {
    "objectID": "notebooks/clt.html#m√©thode-de-monte-carlo",
    "href": "notebooks/clt.html#m√©thode-de-monte-carlo",
    "title": "Frequentist probability",
    "section": "M√©thode de Monte-Carlo",
    "text": "M√©thode de Monte-Carlo\nFor some complex scenarios it may be impossible to know distribution a priori. To get some insights we can use frequency approach: perform many experiments and define probability of event as the limit of its relative frequency to the total number of experiments.\nFor example let us consider frequential experiment with the 6-sided die, as if we don‚Äôt know probabilities of obtaining each side.\nIf we deal with continuous random variable we also can use histogram to at least approximate form of the density function.\n\nn_draws = 36000\nrv = randint(low=1,high=7)\nresult = np.empty(n_draws)\n\nfor i in range(n_draws):\n    result[i] = rv.rvs(1)[0]\n\nplt.figure(figsize=(10, 5))\nsns.histplot(result)\n\nIn the same way we can try to analyze approximate form of the density function for continuous random variables.\nSince they have infinitely many values, we divide all available space in bins, and just compute how many times our random variable of interest fell in each bin.\n\nb = stats.norm(0, 1)\n\n# Find out global properties of population:\nmu = b.mean()\nvar = b.var()\n\n# Generate Sample Means\nn_draws = 100000\nresult = np.empty(n_draws)\nn_bins = 60\n\nfor i in range(n_draws):\n    result[i] = b.rvs(1)[0]   \n\nplt.figure(figsize=(10, 5))\nsns.histplot(result, bins=n_bins).grid()\ncounts, _, _ = plt.hist(result, bins=n_bins, alpha=0.0)  # just in order to find out the scaling coefficient for PDF\nplt.title('Histogram for standard normal variable')\n\n# scaling of normal PDF is needed, because histogram has large values on y-axis, and we need to fit them\nx_space = np.linspace(-5, 5)\nplt.plot(x_space, np.max(counts) * stats.norm.pdf(x_space, 0, 1) * np.sqrt(2 * np.pi), label='Normal density')\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "notebooks/clt.html#transition-to-the-central-limit-theorem-2-dices",
    "href": "notebooks/clt.html#transition-to-the-central-limit-theorem-2-dices",
    "title": "Frequentist probability",
    "section": "Transition to the Central Limit Theorem: 2 dices",
    "text": "Transition to the Central Limit Theorem: 2 dices\nLet us return to the first example with 6-sided dice. But for now suppose we have 2 independent dices and we now observe two random variables at once: discrete bivariate vector \\((X,Y)\\).\nNew random variable \\(T = f(X,Y) = X + Y\\) is clearly a function from \\(X\\) and \\(Y\\) and also is a random variables itself. It is possible to obtain its probability mass function (PMF) theoretically, but let us apply our simulation and see how the histogram looks like.\n\nn_draws = 36000\nrv = randint(low=1,high=7)\nresult = np.empty(n_draws)\n\n\nfor i in range(n_draws):\n    x = rv.rvs(1)[0]\n    y = rv.rvs(1)[0]\n    result[i] = x + y\n\nplt.figure(figsize=(10, 5))\nsns.histplot(result)"
  },
  {
    "objectID": "notebooks/clt.html#transition-to-the-central-limit-theorem-3-dices",
    "href": "notebooks/clt.html#transition-to-the-central-limit-theorem-3-dices",
    "title": "Frequentist probability",
    "section": "Transition to the Central Limit Theorem: 3 dices",
    "text": "Transition to the Central Limit Theorem: 3 dices\nIn this example we go even further and here we have 3 independent dices, which means we observe three random variables at once: discrete vector \\((X_1, X_2, X_3)\\).\nAgain we are going to look at their sum - random variable \\(T = X_1 + X_2 + X_3\\).\n\nn_draws = 36000\nrv = randint(low=1,high=7)\nresult = np.empty(n_draws)\n\n\nfor i in range(n_draws):\n    x_1 = rv.rvs(1)[0]\n    x_2 = rv.rvs(1)[0]\n    x_3 = rv.rvs(1)[0]\n    result[i] = x_1 + x_2 + x_3\n\nplt.figure(figsize=(10, 5))\nsns.histplot(result)"
  },
  {
    "objectID": "notebooks/clt.html#transition-to-the-central-limit-theorem-5-dices",
    "href": "notebooks/clt.html#transition-to-the-central-limit-theorem-5-dices",
    "title": "Frequentist probability",
    "section": "Transition to the Central Limit Theorem: 5 dices",
    "text": "Transition to the Central Limit Theorem: 5 dices\nIn this example we go even further and here we have 5 independent dices, which means we observe five random variables at once: discrete vector \\((X_1, X_2, X_3, X_4, X_5)\\).\nAgain we are going to look at their sum - random variable \\(T = X_1 + X_2 + X_3 + X_4 + X_5\\).\n\nn_draws = 100000\nrv = randint(low=1,high=7)\nresult = np.empty(n_draws)\n\n\nfor i in range(n_draws):\n    x_1 = rv.rvs(1)[0]\n    x_2 = rv.rvs(1)[0]\n    x_3 = rv.rvs(1)[0]\n    x_4 = rv.rvs(1)[0]\n    x_5 = rv.rvs(1)[0]\n    result[i] = x_1 + x_2 + x_3 + x_4 + x_5\n\nplt.figure(figsize=(10, 5))\nsns.histplot(result)"
  },
  {
    "objectID": "notebooks/clt.html#philosophical-form",
    "href": "notebooks/clt.html#philosophical-form",
    "title": "Frequentist probability",
    "section": "‚ÄòPhilosophical‚Äô form",
    "text": "‚ÄòPhilosophical‚Äô form\n\nLet \\(X_1, \\ldots, X_n\\) be a sequence of independent random variables taken from the same distribution, i.e.¬†all \\(X_i\\)‚Äôs have the same expectation \\(\\mu\\) and finite variance \\(\\sigma^2\\). Let us construct new random variable:\n\n\\[\nS_n = \\sum \\limits_{i=1}^{n} X_i.\n\\]\n\nAccording to the properties of expectation and variance, properties of the new random variable are:\n\n\\[\\begin{gather}\n    E[S_n] = E \\Bigl[ \\sum \\limits_{i=1}^{n} X_i \\Bigr] = \\sum \\limits_{i=1}^{n} E[X_i] = n \\mu \\\\\n    Var[S_n] = Var \\Bigl[ \\sum \\limits_{i=1}^{n} X_i \\Bigr] = \\sum \\limits_{i=1}^{n} Var[X_i] = n \\sigma^2\n\\end{gather}\\]\n\nCentral Limit Theorem: distribution of such random variable \\(S_n\\) tends to normal as \\(n \\rightarrow \\infty\\): \\(S_n  \\rightarrow  Y \\sim \\mathcal{N}(n \\mu, n \\sigma^2)\\). More specifically formulated:\n\n\\[\n  \\forall x \\in \\mathbb{R} \\quad  P(S_n &lt; x) \\underset{n \\rightarrow \\infty}{\\longrightarrow} P(Y &lt; x), \\text{ where } Y \\sim \\mathcal{N}(n \\mu, n \\sigma^2).\n\\]\n\nIn simple words, we can just say that \\(S_n \\sim \\mathcal{N}(n \\mu, n \\sigma^2)\\), when \\(n\\) is sufficiently large.\n\n\nOnce again, sum of many ANY random variables gives us.. normal?\n\n\nLooks like cheap scam!\nTo prove that let‚Äôs take random variable that is faaar from being normal.\nHow on Earth the density function of sum of them can at least remotely resemble normal distribution?\n\nb = stats.beta(0.05, 0.09)\n\n# Find out global properties of population:\nmu = b.mean()\nvar = b.var()\n\n# Generate Sample Means\nn_draws = 10000\nrandom_var = np.empty(n_draws)\nn_bins = 20\n\nfor i in range(n_draws):\n    random_var[i] = np.random.beta(0.05, 0.05)   \n\nplt.figure(figsize=(10, 5))\nsns.histplot(random_var, bins=n_bins).grid()\ncounts, _, _ = plt.hist(random_var, bins=n_bins, alpha=0.0)  # just in order to find out the scaling coefficient for PDF\nplt.title('Histogram for beta random variable')\n\n# scaling of normal PDF is needed, because histogram has large values on y-axis, and we need to fit them\nx_space = np.linspace(-3, 3)\nplt.plot(x_space, np.max(counts) * stats.norm.pdf(x_space, 0, 1) * np.sqrt(2 * np.pi), label='Normal density')\nplt.legend()\nplt.show()\n\n\nplt.figure(figsize=(10, 5))\n\nplt.title('True density of beta random variable')\n\n# scaling of normal PDF is needed, because histogram has large values on y-axis, and we need to fit them\nx_space = np.linspace(-1, 3, 10001)\nplt.plot(x_space, b.pdf(x_space), label='beta density')\nplt.grid()\nplt.legend()\nplt.show()\n\n\nb = stats.beta(0.05, 0.09)\n\n# Find out global properties of population:\nmu = b.mean()\nsigma = np.sqrt(b.var())\nvar = b.var()\n\nprint(\"Parameters of a single random variable: Mean = {}, Var = {}\".format(mu, var))\n\n# Generate Sample Means\nn_draws = 10000\nx_totals = np.empty(n_draws)\nn_bins = 50\nfor sample_size in range(1, 50):\n    for i in range(n_draws):\n        sample = b.rvs(size=sample_size)\n        x_totals[i] = np.sum(sample)    \n    \n    plt.figure(figsize=(12, 3))\n    sns.histplot(x_totals, bins=n_bins).grid()\n    counts, _, _ = plt.hist(x_totals, bins=n_bins, alpha=0.0)  # just in order to find out the scaling coefficient for PDF\n    if sample_size == 1:\n        plt.title(r'Approximate density shape of variable $(X_1)$')\n    else:\n        plt.title(r'Approximate density shape of variable $(X_1 + \\ldots + X_{%d})$' % (sample_size))\n    \n    # scaling of normal PDF is needed, because histogram has large values on y-axis, and we need to fit them\n    x_space = np.linspace(sample_size * mu - 3 * var * sample_size, sample_size * mu + 3 * var * sample_size, 1000)\n    current_std = np.sqrt(var * sample_size)\n    plt.plot(x_space, np.max(counts) * stats.norm.pdf(x_space, sample_size * mu, current_std) * np.sqrt(2 * np.pi) * current_std, label=r'$\\mathcal{N} \\; \\left(%s \\cdot %s, \\; %s \\sigma^2\\right)$' % (sample_size, mu, sample_size))\n    plt.legend()\n    plt.show()\n    # plt.savefig('plot_{}.png'.format(sample_size))\n    plt.close()"
  },
  {
    "objectID": "notebooks/clt.html#more-widespread-formulation",
    "href": "notebooks/clt.html#more-widespread-formulation",
    "title": "Frequentist probability",
    "section": "More widespread formulation",
    "text": "More widespread formulation\nMore often in textbooks we can meet another formulation of CLT.\nFirstly, recall that if \\(X\\) is any normal random variable, then the following function makes it standard normal:\n\\[\n    Z = \\frac{X - E[X]}{\\sqrt{Var[X]}}, \\quad Z \\sim \\mathcal{N}(0,1)\n\\]\n\nLet \\(X_1, \\ldots, X_n\\) be a sequence of independent random variables taken from the same distribution, i.e.¬†all \\(X_i\\)‚Äôs have the same expectation \\(\\mu\\) and finite variance \\(\\sigma^2\\).\nAs before we construct new random variable: \\[\n  S_n = \\sum \\limits_{i=1}^{n} X_i, \\quad E[S_n] = n \\mu, \\quad Var[S_n] = n \\sigma^2.\n\\]\nLet us apply tranformation to \\(S_n\\): \\[\n  Z_n = \\frac{S_n - E[S_n]}{\\sqrt{Var[S_n]}} = \\frac{S_n - n \\mu}{\\sigma \\sqrt{n}}\n\\]\nProperties of this new random variable: \\[\\begin{gather}\n  E[Z_n] = E \\Bigl[\\frac{S_n}{\\sigma \\sqrt{n}} - \\frac{n \\mu}{\\sigma \\sqrt{n}} \\Bigr] = E \\Bigl[\\frac{S_n}{\\sigma \\sqrt{n}} \\Bigl] - E \\Bigl[\\frac{n \\mu}{\\sigma \\sqrt{n}} \\Bigr] = \\frac{n \\mu}{\\sigma \\sqrt{n}} - \\frac{n \\mu}{\\sigma \\sqrt{n}} = 0 \\\\\n  Var[Z_n] = Var \\Bigl[\\frac{S_n}{\\sigma \\sqrt{n}} - \\frac{n \\mu}{\\sigma \\sqrt{n}} \\Bigr] = Var \\Bigl[\\frac{S_n}{\\sigma \\sqrt{n}} \\Bigl] + Var \\Bigl[\\frac{n \\mu}{\\sigma \\sqrt{n}} \\Bigr] = \\frac{Var[S_n]}{n \\sigma^2} + 0 = 1.\n\\end{gather}\\]\nCentral Limit Theorem: distribution of such random variable \\(Z_n\\) tends to standard normal as \\(n \\rightarrow \\infty\\): \\(Z_n  \\rightarrow  Z \\sim \\mathcal{N}(0, 1)\\).\nIn simple words, if \\(n\\) is large enough, then we can say that \\(S_n \\sim \\mathcal{N}(n \\mu, n \\sigma^2)\\), and simultaneously random variable \\(Z_n = \\frac{S_n - n\\mu}{\\sigma \\sqrt{n}}\\) has standard normal distribution i.e. \\(Z_n \\sim \\mathcal{N}(0, 1)\\).\n\n\nb = stats.beta(0.05, 0.05)\n\n# Find out global properties of population:\nmu = b.mean()\nsigma = np.sqrt(b.var())\nvar = b.var()\n\n# Generate Sample Means\nn_draws = 10000\nx_totals = np.empty(n_draws)\nn_bins = 50\n\nfor sample_size in range(1, 35):\n    for i in range(n_draws):\n        sample = b.rvs(size=sample_size)\n        x_totals[i] = np.sum(sample)    \n\n    # transformation of all realizations to standard normal\n    z = (x_totals - sample_size * mu) / np.sqrt(var * sample_size)\n    plt.figure(figsize=(10, 5))\n    sns.histplot(z, bins=n_bins).grid()\n    counts, _, _ = plt.hist(z, bins=n_bins, alpha=0.0)  # just in order to find out the scaling coefficient for PDF\n    plt.title(r'Approximate density shape of variable $Z_n$ (sample size = {})'.format(sample_size))\n\n    # scaling of standard normal PDF, because histogram has large values on y-axis, and we need to fit them\n    x_space = np.linspace(-5, 5)\n    plt.plot(x_space, np.max(counts) * stats.norm.pdf(x_space, 0, 1) * np.sqrt(2 * np.pi), label='Standard Normal')\n    plt.legend()\n    plt.show()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Main",
    "section": "",
    "text": "–¢–µ–æ—Ä–∏—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–π –∏ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n\n\nTeam\n\n\n    \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      –ì–ª–µ–± –ö–∞—Ä–ø–æ–≤\n                    \n                    –õ–µ–∫—Ç–æ—Ä\n                  \n                \n              \n        \n    \n\n–ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤"
  },
  {
    "objectID": "program.html",
    "href": "program.html",
    "title": "üöÄ –ú–∞—Ç–µ—Ä–∏–∞–ª—ã",
    "section": "",
    "text": "–ó–∞–Ω—è—Ç–∏–µ 1\n    \n        üìÑ –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è ‚Ä¢ üìù –ó–∞–º–µ—Ç–∫–∏\n    \n    \n        \n    \n    –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–Ω–æ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ. –ê–∫—Å–∏–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏.\n\n–ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤"
  },
  {
    "objectID": "notebooks/sampling_distribution.html",
    "href": "notebooks/sampling_distribution.html",
    "title": "Sampling distribution",
    "section": "",
    "text": "import numpy as np\nimport seaborn as sns\nimport scipy.stats as stats\nfrom matplotlib import pyplot as plt\n\n\nThe first example: sample of dice rolls\nWhat do you see on the following picture?\nThis is a visual representation of the fact that each function from the sample, e.g.¬†sample mean, also has a random nature! And each time you generate new sample, the value of the chosen function will be different.\nTry to change sample_size variable and see what happens.\n\nn_draws = 100\nsample_size = 100000\nr = stats.randint(1,7)\nmu = r.mean()\nvar = r.var()\nsample_mean_realizations = np.empty(n_draws)\nrv_realizations = np.empty(n_draws)\n\n\nfor i in range(n_draws):\n    sample_realization = r.rvs(size=sample_size)\n    sample_mean_realizations[i] = np.mean(sample_realization)\n    rv_realizations[i] = r.rvs()\n\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(12, 8))\nax1.scatter(np.arange(n_draws), rv_realizations, label=r'single RV realization, $x$')\nax1.axhline(r.mean(), color='green', label = 'True mean')\nax2.scatter(np.arange(n_draws), sample_mean_realizations, label=r'Sample mean realization, $\\bar{x}$')\nax2.axhline(r.mean(), color='green', label = 'True mean')\n\n\nylim = ax1.get_ylim()\nax2.set_ylim(ylim)\n\nax1.legend()\nax2.legend()\nax1.set_title(r'Different random realizations of a single random variable $X$')\nax2.set_title(r'Different random realizations of sample mean $\\bar{X}$, sample size = %d' % sample_size)\nplt.show()\n\n\n\n\n\n\n\n\nIf on the previous picture we present just a few different realiations, in the following we generate much more samples and try to approximate the probability density function by plotting a histogram.\nAs well, try to change sample_size in below and see what happens with the histogram.\n\nn_draws = 1000\nsample_size = 500\nn_bins = 50\nr = stats.randint(1,7)\nsample_mean_realizations = np.empty(n_draws)\nrv_realizations = np.empty(n_draws)\n\nfor i in range(n_draws):\n    sample_realization = r.rvs(size=sample_size)\n    sample_mean_realizations[i] = np.mean(sample_realization)\n    rv_realizations[i] = r.rvs()\n\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(12, 8))\n\nsns.histplot(rv_realizations, bins=n_bins, ax=ax1).grid()\n\nsns.histplot(sample_mean_realizations, bins=n_bins, ax=ax2).grid()\ncounts, _, _ = plt.hist(sample_mean_realizations, bins=n_bins, alpha=0.0)  # just in order to find out the scaling coefficient for PDF\nplt.title('Histogram for standard normal variable')\n#     plt.axvline(x=np.mean(z), label='Mean of Sample Means')\n\n# scaling of normal PDF is needed, because histogram has large values on y-axis, and we need to fit them\nx_space = np.linspace(mu - 3 * var,  mu + 3 * var, 1000)\nax2.plot(x_space, np.max(counts) * stats.norm.pdf(x_space, mu, np.sqrt(var / sample_size)) * np.sqrt(2 * np.pi * var / sample_size), label='Normal density')\n# ax1.legend()\n# ax2.legend()\nax1.set_title('Histogram for realizations of a single RV')\nax2.set_title(r'Histogram for realizations of sample mean $\\bar{X}$, sample size = %d' % sample_size)\nplt.show()\n\n\n\n\n\n\n\n\n\n\nThe second example: sampling from normal distribution\n\nr = stats.norm(5000, 200)\nn_draws = 100\nsample_size = 30\nmu = r.mean()\nvar = r.var()\nstd = r.std()\nsample_mean_realizations = np.empty(n_draws)\nrv_realizations = np.empty(n_draws)\n\n\nfor i in range(n_draws):\n    sample_realization = r.rvs(size=sample_size)\n    sample_mean_realizations[i] = np.mean(sample_realization)\n    rv_realizations[i] = r.rvs()\n\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(12, 8))\nax1.scatter(np.arange(n_draws), rv_realizations, label=r'single RV realization, $x$')\nax1.axhline(r.mean(), color='green', label = 'True mean')\nax1.axhline(r.mean() + std, color='blue', label = r'$\\mu + \\sigma$')\nax1.axhline(r.mean() - std, color='blue', label = r'$\\mu - \\sigma$')\n\nax2.scatter(np.arange(n_draws), sample_mean_realizations, label=r'Sample mean realization, $\\bar{x}$')\nax2.axhline(r.mean(), color='green', label = 'True mean')\nax2.axhline(r.mean() + std, color='blue', label = r'$\\mu + \\sigma$')\nax2.axhline(r.mean() - std, color='blue', label = r'$\\mu - \\sigma$')\nax1.legend(loc='best')\nax2.legend(loc='best')\nax1.set_title(r'Different random realizations of a single random variable $X \\sim N$({},{})'.format(mu,var))\nax2.set_title(r'Different random realizations of sample mean $\\bar{X}$, sample size = %d' % sample_size)\nplt.show()\n\n\n\n\n\n\n\n\n\nn_draws = 10000\nsample_size = 1000\nn_bins = 50\nsample_mean_realizations = np.empty(n_draws)\nrv_realizations = np.empty(n_draws)\n\nfor i in range(n_draws):\n    sample_realization = r.rvs(size=sample_size)\n    sample_mean_realizations[i] = np.mean(sample_realization)\n    rv_realizations[i] = r.rvs()\n\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(12, 8))\n\nsns.histplot(rv_realizations, bins=n_bins, ax=ax1).grid()\n\nsns.histplot(sample_mean_realizations, bins=n_bins, ax=ax2).grid()\ncounts, _, _ = plt.hist(sample_mean_realizations, bins=n_bins, alpha=0.0)  # just in order to find out the scaling coefficient for PDF\nplt.title('Histogram for standard normal variable')\n#     plt.axvline(x=np.mean(z), label='Mean of Sample Means')\n\n# scaling of normal PDF is needed, because histogram has large values on y-axis, and we need to fit them\nx_space = np.linspace(mu - 3 * var,  mu + 3 * var, 1000)\nax2.plot(x_space, np.max(counts) * stats.norm.pdf(x_space, mu, np.sqrt(var / sample_size)) * np.sqrt(2 * np.pi * var / sample_size), label='Normal density')\nax1.legend()\nax2.legend()\nax1.set_title('Histogram for realizations of a single RV')\nax2.set_title(r'Histogram for realizations of sample mean $\\bar{X}$, sample size = %d' % sample_size)\nplt.show()\n\n/tmp/ipython-input-3742480432.py:13: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n  ax1.legend()\n\n\n\n\n\n\n\n\n\n\n\nThe third example: sample variance from dice rolls\nWhat do you see on the following picture?\nThis is a visual representation of the fact that sample variance also has a random nature! Each time you generate a new sample, the value of the sample variance will be different.\nTry to change sample_size variable and see what happens.\n\nn_draws = 100\nsample_size = 100000\nr = stats.randint(1,7)\nmu = r.mean()\nvar = r.var()\nsample_variance_realizations = np.empty(n_draws)\nrv_realizations = np.empty(n_draws)\n\n\nfor i in range(n_draws):\n    sample_realization = r.rvs(size=sample_size)\n    sample_variance_realizations[i] = np.var(sample_realization, ddof=1)  # unbiased estimator\n    rv_realizations[i] = r.rvs()\n\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(12, 8))\nax1.scatter(np.arange(n_draws), rv_realizations, label=r'single RV realization, $x$')\nax1.axhline(r.mean(), color='green', label = 'True mean')\nax2.scatter(np.arange(n_draws), sample_variance_realizations, label=r'Sample variance realization, $s^2$')\nax2.axhline(r.var(), color='green', label = 'True variance')\n\n\nylim = ax1.get_ylim()\nax2.set_ylim(ylim)\n\nax1.legend()\nax2.legend()\nax1.set_title(r'Different random realizations of a single random variable $X$')\nax2.set_title(r'Different random realizations of sample variance $S^2$, sample size = %d' % sample_size)\nplt.show()\n\nIf on the previous picture we present just a few different realizations, in the following we generate much more samples and try to approximate the probability density function by plotting a histogram.\nAs well, try to change sample_size in below and see what happens with the histogram.\n\nn_draws = 1000\nsample_size = 500\nn_bins = 50\nr = stats.randint(1,7)\nsample_variance_realizations = np.empty(n_draws)\nrv_realizations = np.empty(n_draws)\n\nfor i in range(n_draws):\n    sample_realization = r.rvs(size=sample_size)\n    sample_variance_realizations[i] = np.var(sample_realization, ddof=1)  # unbiased estimator\n    rv_realizations[i] = r.rvs()\n\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(12, 8))\n\nsns.histplot(rv_realizations, bins=n_bins, ax=ax1).grid()\n\nsns.histplot(sample_variance_realizations, bins=n_bins, ax=ax2).grid()\ncounts, _, _ = plt.hist(sample_variance_realizations, bins=n_bins, alpha=0.0)  # just in order to find out the scaling coefficient for PDF\n\n# For large sample sizes, sample variance is approximately normal\n# E[S^2] = œÉ¬≤, Var[S^2] ‚âà 2œÉ‚Å¥/(n-1) for normal distribution\n# For uniform distribution, the approximation is less accurate but still useful\nx_space = np.linspace(0, 3 * var, 1000)\nax2.plot(x_space, np.max(counts) * stats.norm.pdf(x_space, var, np.sqrt(2 * var**2 / (sample_size - 1))) * np.sqrt(2 * np.pi * 2 * var**2 / (sample_size - 1)), label='Normal approximation', color='red')\n\nax1.set_title('Histogram for realizations of a single RV')\nax2.set_title(r'Histogram for realizations of sample variance $S^2$, sample size = %d' % sample_size)\nax2.axvline(var, color='green', linestyle='--', label='True variance')\nax2.legend()\nplt.show()\n\n\n\nThe fourth example: sample variance from normal distribution\n\nr = stats.norm(5000, 200)\nn_draws = 100\nsample_size = 30\nmu = r.mean()\nvar = r.var()\nstd = r.std()\nsample_variance_realizations = np.empty(n_draws)\nrv_realizations = np.empty(n_draws)\n\n\nfor i in range(n_draws):\n    sample_realization = r.rvs(size=sample_size)\n    sample_variance_realizations[i] = np.var(sample_realization, ddof=1)  # unbiased estimator\n    rv_realizations[i] = r.rvs()\n\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(12, 8))\nax1.scatter(np.arange(n_draws), rv_realizations, label=r'single RV realization, $x$')\nax1.axhline(r.mean(), color='green', label = 'True mean')\nax1.axhline(r.mean() + std, color='blue', label = r'$\\mu + \\sigma$')\nax1.axhline(r.mean() - std, color='blue', label = r'$\\mu - \\sigma$')\n\nax2.scatter(np.arange(n_draws), sample_variance_realizations, label=r'Sample variance realization, $s^2$')\nax2.axhline(r.var(), color='green', label = 'True variance')\nax2.axhline(r.var() + np.sqrt(2 * var**2 / (sample_size - 1)), color='blue', label = r'$\\sigma^2 + \\sqrt{Var(S^2)}$')\nax2.axhline(r.var() - np.sqrt(2 * var**2 / (sample_size - 1)), color='blue', label = r'$\\sigma^2 - \\sqrt{Var(S^2)}$')\nax1.legend(loc='best')\nax2.legend(loc='best')\nax1.set_title(r'Different random realizations of a single random variable $X \\sim N$({},{})'.format(mu,var))\nax2.set_title(r'Different random realizations of sample variance $S^2$, sample size = %d' % sample_size)\nplt.show()\n\n\nn_draws = 10000\nsample_size = 1000\nn_bins = 50\nsample_variance_realizations = np.empty(n_draws)\nrv_realizations = np.empty(n_draws)\n\nfor i in range(n_draws):\n    sample_realization = r.rvs(size=sample_size)\n    sample_variance_realizations[i] = np.var(sample_realization, ddof=1)  # unbiased estimator\n    rv_realizations[i] = r.rvs()\n\n\nfig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, figsize=(12, 8))\n\nsns.histplot(rv_realizations, bins=n_bins, ax=ax1).grid()\n\nsns.histplot(sample_variance_realizations, bins=n_bins, ax=ax2).grid()\ncounts, _, _ = plt.hist(sample_variance_realizations, bins=n_bins, alpha=0.0)  # just in order to find out the scaling coefficient for PDF\n\n# For normal distribution, (n-1)*S¬≤/œÉ¬≤ ~ œá¬≤(n-1)\n# So S¬≤ ~ (œÉ¬≤/(n-1)) * œá¬≤(n-1)\n# E[S¬≤] = œÉ¬≤, Var[S¬≤] = 2œÉ‚Å¥/(n-1)\nx_space = np.linspace(var - 3 * np.sqrt(2 * var**2 / (sample_size - 1)), var + 3 * np.sqrt(2 * var**2 / (sample_size - 1)), 1000)\nax2.plot(x_space, np.max(counts) * stats.norm.pdf(x_space, var, np.sqrt(2 * var**2 / (sample_size - 1))) * np.sqrt(2 * np.pi * 2 * var**2 / (sample_size - 1)), label='Normal approximation', color='red')\n\nax1.set_title('Histogram for realizations of a single RV')\nax2.set_title(r'Histogram for realizations of sample variance $S^2$, sample size = %d' % sample_size)\nax2.axvline(var, color='green', linestyle='--', label='True variance')\nax2.legend()\nplt.show()"
  }
]